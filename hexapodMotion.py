from __future__ import division
from Adafruit_PWM_Servo_Driver import PWM
from scipy.optimize import fsolve
import time 
import math
import thread

# math functions converted to degrees
def sin(angle):
	return math.sin(math.radians(angle))

def asin(x):
	return math.degrees(math.asin(x))
	
def cos(angle):
	return math.cos(math.radians(angle))

def acos(x):
	return math.degrees(math.acos(x))
	
def tan(angle):
	return math.tan(math.radians(angle))

	
# mechanical parameters in cm (between rotational points)
coxaFemurLen = 1.7
femurLen = 8.0
tibiaLen = 12.5

# global absolute limits for servo travel. pulseLen/4096 is the duration the pulse is set high
minPulseLen = 170
maxPulseLen = 580

# coxa positive movement ccw from top view (0 point with leg perpendicular to body)
# femur positive movement ccw from rearview (0 point parallel to floor)
# tibia positive movement ccw from rearview (0 point when right angle to femur)
# leg 1 is the rear right leg. leg number increasing ccw looking from top

# servo calibration values. order: pulseLen1, pulseLen2, degrees at pulseLen1, degrees at pulseLen2. linear interpolation/extrapolation calculated from these
servoParameters = { 
	"coxa1": [376, 255, 0, 45],
	"coxa2": [353, 255, 0, 40],
	"coxa3": [365, 255, 0, 43],
	"coxa4": [360, 455, 0, 29],
	"coxa5": [401, 475, 0, 25],
	"coxa6": [365, 475, 0, 35],
	"femur1": [369, 575, 0, 75],
	"femur2": [351, 568, 0, 77],
	"femur3": [386, 192, 0, 73],
	"femur4": [392, 580, 0, 67],
	"femur5": [380, 180, 0, 75],
	"femur6": [382, 170, 0, 69],
	"tibia1": [340, 582, 0, 75],
	"tibia2": [340, 180, 0, 75],
	"tibia3": [359, 180, 0, 75],
	"tibia4": [380, 582, 0, 75],
	"tibia5": [347, 582, 0, 75],
	"tibia6": [367, 180, 0, 75]
}

# channel map on the pwm chips. legs 1-3 are on pwmR, 4-6 on pwmL
servoChans = {
	"coxa1": 0,
	"coxa2": 3,
	"coxa3": 11,
	"coxa4": 4,
	"coxa5": 12,
	"coxa6": 15,
	"femur1": 1,
	"femur2": 4,
	"femur3": 12,
	"femur4": 3,
	"femur5": 11,
	"femur6": 14,
	"tibia1": 2,
	"tibia2": 5,
	"tibia3": 13,
	"tibia4": 2,
	"tibia5": 10,
	"tibia6": 13,
}

# calculates the servo pulse length for a desired angle. assumes angle is linear wrt pulseLen
def getPulseLenFromAngle(legSection, angle):
	totalSteps = servoParameters[legSection][1] - servoParameters[legSection][0]
	totalAngle = servoParameters[legSection][3] - servoParameters[legSection][2]
	slope = totalSteps / totalAngle
	intercept = servoParameters[legSection][0] - slope * servoParameters[legSection][2]
	pulseLen = slope * angle + intercept
	return int(round(pulseLen, 0))

class hexapodMotion:

	testMode = False

	# allows or disallows changing of leg angles. this is to prevent femur going down when coxa is repositioning itself after end of powerstroke
	legCommandLock = {
		'1': False,
		'2': False,
		'3': False,
		'4': False,
		'5': False,
		'6': False
	}

	# initial mechanical parameters (i.e. while standing and default walking position)
	femurStandStartAngle = 20
	tibiaStandStartAngle = -10
	coxaStandStartAngle	= 0
	
	
	# walk parameters
	walkSpeed = 0 # float value from -1 to 1. sign gives direction of walking
	
	walkResolution = 60 # number of steps for one full walk cycle. some of these are technically "skipped" when repositioning for powerstroke
	stepAngle = 360 / walkResolution # degrees in each small step in the cycle
	coxaWalkSweepAngle = 27 # half of the total sweep angle for each leg
	

	# servo takes 0.22s to go 60 degrees @ 6V so guarantee femur is in air for legCommandLockTime seconds. max walkspeed depends on this value
	legCommandLockTime = 0.22 * (2 * coxaWalkSweepAngle / 60) + 0.1
	stepTimeInterval = 0.001 # the minimum interval in seconds between successive walk, rotation etc. commands. a multiplier for this is calculated based on walkSpeed 
	
	
	# current leg walk angles. on initialization of the class these will get generated by generateLegWalkOffsets
	legWalkAngles = {
		'1': 0,
		'2': 0,
		'3': 0,
		'4': 0,
		'5': 0,
		'6': 0
	}
	
	# cache for the femur and tibia angle calculations during walking
	servoTibiaFemurAnglesCache = {
	}

	def __init__(self):
		addressPwmL = 0x41
		addressPwmR = 0x40
		
		if self.testMode == False:
			# initialise the PWM devices
			self.pwmL = PWM(addressPwmL, debug=False) # left side (view from rear)
			self.pwmL.setPWMFreq(60) # frequency in Hz 
			self.pwmR = PWM(addressPwmR, debug=False) # right side 
			self.pwmR.setPWMFreq(60) # frequency in Hz
			print "PCA9685 modules initialized. pwmL:" + str(addressPwmL) + " pwmR:" + str(addressPwmR)
		
		
		# calculated initial robot parameters
		self.robotHeight = self.calcRobotHeight(self.femurStandStartAngle, self.tibiaStandStartAngle)
		self.stanceWidth = self.calcStanceWidth(self.femurStandStartAngle, self.tibiaStandStartAngle)
		self.tibiaIntersectWidth = self.calcTibiaIntersectWidth(self.femurStandStartAngle, self.tibiaStandStartAngle)
		
		
		# fill the walkvalues with initial defaults
		self.generateLegWalkOffsets()
		
		# create servo angle cache
		#self.createServoTibiaFemurAnglesCache()
			
		
	# the initial offsets in the walk angle between legs
	def generateLegWalkOffsets(self):
		self.legWalkAngles['1'] = -240
		self.legWalkAngles['2'] = -120
		self.legWalkAngles['3'] = 0
		self.legWalkAngles['4'] = -180
		self.legWalkAngles['5'] = -300
		self.legWalkAngles['6'] = -60
		
	def moveServoToAngle(self, legSection, angle):
		servoChan = servoChans[legSection]
		legNum = int(legSection[-1:])
		pulseLen = getPulseLenFromAngle(legSection, angle)
		if 1 <= legNum <= 3:
			pwm = self.pwmR
		else:
			pwm = self.pwmL
		if minPulseLen <= pulseLen <= maxPulseLen:
			#print "servo " + legSection + " told to go to pos: " + str(pulseLen)
			pwm.setPWM(servoChan, 0, pulseLen)
		else:
			print "servo " + legSection + " told to go to an out of range pos: " + str(pulseLen)
	

	# walk supporting functions
	
	# calculate direction based on walkSpeed value
	def direction(self):
		if self.walkSpeed < 0: return -1
		if self.walkSpeed == 0: return 0
		if self.walkSpeed > 0: return 1
	
	# modify the walking speed based on float input -1 to 1, i.e. from the right (r3) analog stick.
	def stepIntervalMultiplier(self):
		minTimeInterval = self.legCommandLockTime / self.walkResolution # the minimum delay between commanded steps, dependent on servo speed
		
		minScale = int(minTimeInterval / self.stepTimeInterval) + 5 # min scale value. don't want to send commands too fast
		maxScale = 80 # max scale value. set so robot has a reasonable minimum speed
		scale = int((1 - math.fabs(self.walkSpeed)) * maxScale)
		if scale > maxScale: scale == maxScale
		if scale <= 0: scale = minScale
		return (scale)

	# vertical distance from ground(tibia tip) to femur/coxa pivot point (robot height)
	def calcRobotHeight(self, femurAngle, tibiaAngle):
		return tibiaLen * cos(femurAngle + tibiaAngle) - femurLen * sin(femurAngle)

	# horizontal distance (on floor) from tibia tip to femur pivot point
	def calcStanceWidth(self, femurAngle, tibiaAngle):
		return femurLen * cos(femurAngle) + tibiaLen * sin(femurAngle + tibiaAngle)
		
	# horizontal distance from femur pivot point to tibia intersect
	def calcTibiaIntersectWidth(self, femurAngle, tibiaAngle):
		return femurLen * cos(femurAngle) + femurLen * sin(femurAngle) * tan(femurAngle + tibiaAngle)

	
	# lookup cache to prevent needless recalculation of tibia and femur angles (very costly!)
	def putServoTibiaFemurAnglesInCache(self, leg, coxaAngle, angles):
		if leg not in self.servoTibiaFemurAnglesCache: self.servoTibiaFemurAnglesCache[leg] = {}
		if coxaAngle not in self.servoTibiaFemurAnglesCache[leg]: self.servoTibiaFemurAnglesCache[leg][coxaAngle] = {}
		self.servoTibiaFemurAnglesCache[leg][coxaAngle] = angles
	
	# perform a servoAngles cache lookup
	def getServoTibiaFemurAnglesInCache(self, leg, coxaAngle):
		if leg not in self.servoTibiaFemurAnglesCache or coxaAngle not in self.servoTibiaFemurAnglesCache[leg]: return ["error"]
		else: return self.servoTibiaFemurAnglesCache[leg][coxaAngle]
		
	# will calculate all angles at once instead of realtime so that it doesn't slow down the speed and repeat calculations needlessly
	def createServoTibiaFemurAnglesCache(self):
		t = time.time()
		print "Generating servo angles cache..."
		self.walkSpeed = 1
		for i in range(4, 5):
			for j in range(0, self.walkResolution + 1):
				leg = str(i)
				coxaAngle = self.coxaWalkSweepAngle * sin(self.legWalkAngles[leg])
				self.tibiaFemurWalkAngles(leg, coxaAngle)
				self.legWalkAngles[leg] += self.stepAngle
		
		self.walkSpeed = 0
		# regenerate initial offsets
		self.generateLegWalkOffsets()
		print self.servoTibiaFemurAnglesCache
		print "Generated tibia and femur angles cache in " + str(time.time() - t) + " seconds."
		
		
	
	# when coxa angle changes during walking, these are the femur and tibia angles to maintain robot height and position of tibia tip on floor without slipping
	def tibiaFemurWalkAngles(self, leg, coxaAngle):
	
		# because only legs 2 and 5 have tibias in line with the femur pivot, these offsets are needed to fudge the math for the other legs which are offset...will fix later
		amountOffset = 25
		coxaAngleOffsets = {
			'1': -amountOffset,
			'2': 0,
			'3': amountOffset,
			'4': amountOffset,
			'5': 0,
			'6': -amountOffset
		}
		coxaAngle += coxaAngleOffsets[leg]

		
		# check if walkAngle already in cache
		cacheResult = self.getServoTibiaFemurAnglesInCache(leg, coxaAngle)
		if cacheResult[0] != "error":
			return cacheResult
		
		print "tibiaFemurWalkAngles being calculated for leg: " + leg + " and coxaangle: " + str(coxaAngle)
		
		
		# robotHeight and stanceWidth need to remain constant for fluid forward movement
	
		#t = time.time()
		d = self.stanceWidth / cos(coxaAngle)
		def f(x):
			eqns = [tibiaLen * cos(x[0] + x[1]) - femurLen * sin(x[0]) - self.robotHeight]
			#eqns.append(-d + femurLen*cos(x[1])/cos(x[0]+x[1]) + self.robotHeight*tan(x[0]+x[1]))
			eqns.append(femurLen * cos(x[0]) + tibiaLen * sin(x[0] + x[1]) - d)
			return eqns
		
		f_roots = fsolve(f, [self.femurStandStartAngle, self.tibiaStandStartAngle], xtol = 0.1) # initial guesses are just the initial values
		#print time.time()-t
		
		# put in cache so dont have to recalculate
		self.putServoTibiaFemurAnglesInCache(leg, coxaAngle, f_roots)
		
		return f_roots
			
	# calculate the commanded servo angles
	def walkServoAngles(self, leg):
	
		# var to hold the coxa, femur and tibia angles
		angles = {}		
		
		# make sure walkAngle is always between 0-360
		self.legWalkAngles[leg] = self.legWalkAngles[leg] % 360
			
		# supporting vars
		if self.legWalkAngles[leg] >= 0: m = 1
		else: m = -1
		
		# if not in the powerstroke, execute a move so that it is
		if not ((m * 90) <= self.legWalkAngles[leg] <= (m * 270)):
			self.legCommandLock[leg] = True # guarantee this function wont be called again for self.legCommandLockTime
			self.timeUnlockLeg(leg)
			self.legWalkAngles[leg] = self.legWalkAngles[leg] + self.direction() * 180

		self.legWalkAngles[leg] = self.legWalkAngles[leg] % 360	
			
		# calculate the angles
		angles["coxa"] = self.coxaWalkSweepAngle * sin(self.legWalkAngles[leg])
		ftAngles = self.tibiaFemurWalkAngles(leg, angles["coxa"])
		angles["femur"] = ftAngles[0]
		angles["tibia"] = ftAngles[1]
			
		if self.legCommandLock[leg] == True:
			angles["femur"] = self.femurStandStartAngle + 20
		
		# debugging
		if leg == "5" and self.direction() != 0 and self.testMode == True:
			if self.direction() == 1: print "walking forward"
			elif self.direction() == -1: print "walking backward"
			print str(time.time()) + ": leg" + leg +  " walkangles: " + str(self.legWalkAngles[leg]) + " " + str(angles)
		
		return angles
	
	# lock leg angles from changing
	def timeUnlockLeg(self, leg):
		thread.start_new_thread(self.timeUnlockLeg_helper, (leg,))
	def timeUnlockLeg_helper(self, leg):
		time.sleep(self.legCommandLockTime)
		self.legCommandLock[leg] = False
	
	# stand function
	def stand(self):
		if self.testMode == False:
			for i in range(1, 7):
				self.moveServoToAngle("coxa" + str(i), self.coxaStandStartAngle)
				self.moveServoToAngle("femur" + str(i), self.femurStandStartAngle + 20)
			 
			time.sleep(1)
			for i in range(1, 7):
				self.moveServoToAngle("tibia" + str(i), self.tibiaStandStartAngle)
			
			time.sleep(1) 
			for i in range(1, 7):
				self.moveServoToAngle("femur" + str(i), self.femurStandStartAngle)
			time.sleep(1)
		
	# walk function
	def walk(self):
		for i in range(1, 7): # leg loop
			leg = str(i)
			
			# call only if leg is not locked and speed is nonzero
			if self.legCommandLock[leg] == False and self.walkSpeed != 0:
				# modify the walkAngles
				self.legWalkAngles[leg] = self.legWalkAngles[leg] + (self.direction() * self.stepAngle)
				
				# get the angles
				angles = self.walkServoAngles(leg)

				# move the servos
				if self.testMode == False:
					self.moveServoToAngle("coxa" + leg, angles["coxa"])
					self.moveServoToAngle("femur" + leg, angles["femur"])
					self.moveServoToAngle("tibia" + leg, angles["tibia"])

		if self.walkSpeed != 0 and self.testMode == True: print ""
		time.sleep(self.stepTimeInterval * self.stepIntervalMultiplier())
		
	# temporary functions
	def __moveServoToPos(self, legSection, pulseLen):
		servoChan = servoChans[legSection]
		legNum = int(legSection[-1:])
		if 1 <= legNum <= 3:
			pwm = self.pwmR
		else:
			pwm = self.pwmL
		if minPulseLen <= pulseLen <= maxPulseLen:
			pwm.setPWM(servoChan, 0, pulseLen)
	def __testServoOffsets(self):
		self.__moveServoToPos("tibia6", 367)
		#self.pwmR.setPWM(12, 0, 580)
		#self.pwmL.setPWM(3, 0, 170)
		
		for i in range(1, 7):
			self.moveServoToAngle("coxa" + str(i), 0)
			self.moveServoToAngle("femur" + str(i), 50)
			#self.moveServoToAngle("tibia" + str(i), 45)					

		